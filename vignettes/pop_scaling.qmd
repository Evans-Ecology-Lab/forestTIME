---
title: "Population scaling"
vignette: >
  %\VignetteIndexEntry{Population scaling}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
format:
  html:
    toc: true
    df-print: paged
    link-external-newwindow: true
    link-external-icon: true
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
---

```{r}
#| label: setup

library(forestTIME.builder)
library(dplyr)
library(rFIA)
library(ggplot2)
library(units)
```

How can we use the interpolated data produced by `forestTIME.builder` to get popluation-level (i.e. state-level) per-area estimates?

## Example data

I'll use RI as an example state because it is small.
We'll use the standard basic workflow to get estimated aboveground carbon for each tree in each year.

::: callout-important
`rFIA` produces estimates of carbon from 33 -- 40.7 tons/acre using design-based estimators.
"Correct" estimates should be in this ballpark.
They will not be exact because **many trees are dropped from the sample by `forestTIME.builder`** either due to changing species or due to only having 1 non-`NA` observation (unable to interpolate).
**This could very well account for the differences observed below!**

```{r}
agc_rfia <- 
  biomass(fiaRI, method = "annual", treeType = "live", areaDomain = COND_STATUS_CD == 1 & INTENSITY == 1) |> 
  mutate(method = "rFIA::biomass()") |> 
  select(method, YEAR, carbon_ton_acre = CARB_ACRE)
mean(agc_rfia$carbon_ton_acre)
```
:::

```{r}
#| label: prep-data
state <- "RI"

# Data Download
get_fia_tables(states = state, keep_zip = FALSE)

# Data prep
db <- read_fia(states = state) #list of data frames

data <- prep_data(db) #single tibble

# Expand to include all years between surveys and interpolate/extrapolate
# Adjust for mortality and estimate carbon.
data_midpt <-
  data |>
  expand_data() |>
  interpolate_data() |>
  adjust_mortality(use_mortyr = FALSE) |>
  prep_carbon() |>
  estimate_carbon() 
```

I'll add domain indicator columns as are done in the `rFIA` demystified vignette so we calculate carbon in live trees per area of forested land using base intensity plots only.
Reason:

> We build separate domain indicators for estimating tree totals and area totals, because we can specify different domains of interest for both.
> For example, if we used our tree domain (live trees on forest land) to estimate area, then we would not actually be estimating the full forested area in RI.
> Instead we would estimate the forested area ONLY where live trees are currently present.

So we can't just `filter(STATUSCD == 1 & COND_STATUSCD == 1)` to estimate carbon tons/acre.

```{r}
data_midpt <-
  data_midpt |>
  mutate(
    aDI = if_else(COND_STATUS_CD == 1 & INTENSITY == 1, 1, 0), #forested land
    tDI = if_else(STATUSCD == 1, 1, 0) * aDI #live trees on forested land
  )
```

## Expansion factors

The FIA data provides users with expansion factors, `EXPNS`, to aid in scaling estimates up to state levels.  There are two issues in using these provided `EXPNS` with our annualized data: 1) it is not straightforward to join the tables in to get the `EXPNS` column, and 2) there are now many more plots in each year, so the `EXPNS` column is no longer accurate (it is the land acres of the entire state represented by each plot).

Let's calculate our own expansion factor using the land area of RI.

[Wikipedia](https://en.wikipedia.org/wiki/Rhode_Island) tells me the land area of RI is 2,678 km^2^ or 661,745.6 acres

```{r}
data_midpt <- data_midpt |> 
  group_by(YEAR) |> 
  mutate(
    EXPNS = 661745.6 / length(unique(plot_ID))
  )
```

Now that we have expansion factors, we can follow the methods in the [FIA demystified vignette](https://doserlab.com/files/rfia/articles/fiademystified#without-sampling-errors).

```{r}
agc_pop <- data_midpt |>
  group_by(
    PLT_CN,
    YEAR
  ) |>
  summarize(
    # purposefully omits ajustment factor `aAdj` because it is assumed to be 1
    carbPlot = sum(CARBON_AG * TPA_UNADJ * EXPNS * tDI / 2000, na.rm = TRUE),
    forArea = sum(CONDPROP_UNADJ * EXPNS * aDI, na.rm = TRUE)
  ) |>
  group_by(YEAR) |>
  summarize(
    CARB_AG_TOTAL = sum(carbPlot, na.rm = TRUE), #Aren't the units here are actually tons/acre??
    AREA_TOTAL = sum(forArea, na.rm = TRUE) #How is a sum of proportions equal to area? What are the units?
  ) |>
# the units work out to still be tons(live carbon)/acre(forested land) even if the variable names are misleading
  mutate(method = "annualized", carbon_ton_acre = CARB_AG_TOTAL / AREA_TOTAL) |> 
  select(method, YEAR, carbon_ton_acre)
agc_pop
```

```{r}
bind_rows(agc_rfia, agc_pop) |> 
  ggplot(aes(x = YEAR, y = carbon_ton_acre, color = method)) +
  geom_line()

```

Ok, these numbers are obviously way off.  The expansion factors themselves are ballpark the same, which actually doesn't seem rightâ€”they should be smaller since there are more plots in each year in our dataset, right?

```{r}
POP_ESTN_UNIT <- select(db$POP_ESTN_UNIT, CN, EVAL_CN, AREA_USED, 
                        P1PNTCNT_EU)
POP_EVAL <- select(db$POP_EVAL, EVALID, EVAL_GRP_CN, ESTN_METHOD, CN, 
                   END_INVYR, REPORT_YEAR_NM)
POP_EVAL_TYP <- select(db$POP_EVAL_TYP, EVAL_TYP, EVAL_CN)
POP_PLOT_STRATUM_ASSGN <- select(db$POP_PLOT_STRATUM_ASSGN, STRATUM_CN, 
                                 PLT_CN)
POP_STRATUM <- select(db$POP_STRATUM, ESTN_UNIT_CN, EXPNS, P2POINTCNT,
                      ADJ_FACTOR_MICR, ADJ_FACTOR_SUBP, ADJ_FACTOR_MACR, 
                      CN, P1POINTCNT)

pop <- POP_PLOT_STRATUM_ASSGN %>%
  left_join(POP_STRATUM, by = c('STRATUM_CN' = 'CN')) %>%
  left_join(POP_ESTN_UNIT, by = c('ESTN_UNIT_CN' = 'CN')) %>%
  left_join(POP_EVAL, by = c('EVAL_CN' = 'CN')) %>%
  left_join(POP_EVAL_TYP, by = 'EVAL_CN', relationship = 'many-to-many')

pop |> filter(EVAL_TYP %in% c("EXPVOL", "EXPCURR")) |> 
  summarize(
    mean = mean(EXPNS),
    median = median(EXPNS)
  )

data_midpt |> ungroup() |> summarize(mean = mean(EXPNS), median = median(EXPNS))
```
