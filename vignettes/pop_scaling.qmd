---
title: "Population scaling"
vignette: >
  %\VignetteIndexEntry{Population scaling}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
format:
  html:
    toc: false
    df-print: paged
    link-external-newwindow: true
    link-external-icon: true
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
bibliography: references.bib
---

```{r}
#| label: setup

library(forestTIME.builder)
library(dplyr)
library(rFIA)
library(ggplot2)
```

How can we use the interpolated data produced by `forestTIME.builder` to get popluation-level (i.e. state-level) per-area estimates?

::: callout-warning
The interpolated values produced by `forestTIME.builder` are *inferences* and not samples, so it may not be appropriate to use (modified) design-based estimators, as we do in this vignette, which treat the data, including interpolated values, as a probablity sample.
:::

## Example data

We'll use RI as an example state because it is small.
We'll just use the built-in example data that comes with `forestTIME.builder`, but if you were to download your own and you wanted to use it with `rFIA` also, make sure to set `extract = "rFIA"` to extract all the tables needed for both `forestTIME.builder` and `rFIA`.

```{r}
#| label: download-data
#| eval: false

fia_download(states = "RI", download_dir = "fia", extract = "rFIA")
```

::: callout-important
`rFIA` produces estimates of carbon from 33 -- 40.7 tons/acre using design-based estimators.
"Correct" estimates should be in this ballpark.

```{r}
#| label: rfia-biomass
rfia_RI <- readFIA(
  dir = system.file("exdata", package = "forestTIME.builder"),
  states = "RI"
)

agc_rfia_annual <-
  biomass(
    rfia_RI,
    totals = TRUE,
    variance = TRUE,
    method = "annual",
    treeType = "live",
    landType = 'forest',
    component = "AG",
    areaDomain = COND_STATUS_CD == 1 & INTENSITY == 1
  ) |>
  mutate(method = "rFIA annual")

agc_rfia_ti <-
  biomass(
    rfia_RI,
    totals = TRUE,
    variance = TRUE,
    method = "TI",
    treeType = "live",
    landType = 'forest',
    component = "AG",
    areaDomain = COND_STATUS_CD == 1 & INTENSITY == 1
  ) |>
  mutate(method = "rFIA TI")

mean(agc_rfia_annual$CARB_ACRE)
mean(agc_rfia_ti$CARB_ACRE)
```
:::

We'll use the standard basic workflow to get estimated aboveground carbon for each tree in each year.

```{r}
#| label: annualize-data

# Data prep
db <- fia_load(
  "RI",
  dir = system.file("exdata", package = "forestTIME.builder")
)
data <- fia_tidy(db) #single tibble

# Expand to include all years between surveys and interpolate/extrapolate
# Adjust for mortality and estimate carbon.
data_midpt <- data |>
  fia_annualize(use_mortyr = FALSE) |>
  fia_estimate()
```

I'll add domain indicator columns as is done in the `rFIA` demystified vignette so we calculate carbon in live trees per area of forested land using base intensity plots only.
Reason:

> We build separate domain indicators for estimating tree totals and area totals, because we can specify different domains of interest for both.
> For example, if we used our tree domain (live trees on forest land) to estimate area, then we would not actually be estimating the full forested area in RI.
> Instead we would estimate the forested area ONLY where live trees are currently present.

So we can't just `filter(STATUSCD == 1 & COND_STATUSCD == 1)` to estimate carbon tons/acre.

```{r}
#| label: domain-indicators

data_midpt <-
  data_midpt |>
  mutate(
    aDI = if_else(COND_STATUS_CD == 1 & INTENSITY == 1, 1, 0), #forested land
    tDI = if_else(STATUSCD == 1, 1, 0) * aDI #live trees on forested land
  )
```

## Expansion factors

The FIA data provides users with expansion factors, `EXPNS`, to aid in scaling estimates up to state levels.
There are two issues in using these provided `EXPNS` with our annualized data: 1) it is not straightforward to join the tables in to get the `EXPNS` column, and 2) there are now many more plots in each year, so the `EXPNS` column is no longer accurate (it is the acres of the entire state represented by each plot).
Therefore, `fia_annualize()` re-calculates the `EXPNS` column as the total land area of the state divided by the number of plots in the interpolated data for that state in each year.\
We think these `EXPNS` values can be used much in the same way as the ones in the "raw" FIA database.

```{r}
#| label: expns

data_midpt |>
  select(YEAR, EXPNS) |>
  group_by(YEAR) |>
  summarize(EXPNS = unique(EXPNS)) |>
  ggplot(aes(x = YEAR, y = EXPNS)) +
  geom_line()
```

You'll notice that the calculated `EXPNS` follow a "U" shape rather than being constant.
That is because in our interpolated data, there are fewer plots in the beginning and end of the timeseries because we do not extrapolate beyond a panel's first and last inventory.

Using these expansion factors, we can follow the methods in the [FIA demystified vignette](https://doserlab.com/files/rfia/articles/fiademystified#without-sampling-errors).

::: callout-warning
The variances calculated below are not *variance estimators* (in the sense that they are not "design-based"), they are just the traditional sample variance of a random variable.
This may not be appropriate to "mix" with the mean and ratio estimators calculated below.

E.g. the variance *estimator* for per-acre ratios (without post-stratification weights) is equation 4.17 in @bechtold2005 and equation 11 in @westfall2022 which is *not* the same as the formula the `var()` function uses to calculate [variance of a random variable](https://en.wikipedia.org/wiki/Variance):

$$
s^2 = \frac{1}{N-1}\sum_{i=1}^N(x_i - \bar{x})^2
$$
:::

```{r}
#| label: estimators

tree_totals <- data_midpt |>
  group_by(plot_ID, YEAR) |>
  summarize(
    # purposefully omits ajustment factor `aAdj` because it is assumed to be 1
    carbPlot = sum(CARBON_AG * TPA_UNADJ * EXPNS * tDI / 2000, na.rm = TRUE), #tons/plot
  )

area_totals <- data_midpt |>
  group_by(plot_ID, YEAR) |>
  # Keep only one row for each condition in each plot and year
  distinct(CONDID, COND_STATUS_CD, CONDPROP_UNADJ, EXPNS, aDI) |>
  summarize(
    # purposefully omits ajustment factor `aAdj` because it is assumed to be 1
    forArea = sum(CONDPROP_UNADJ * EXPNS * aDI, na.rm = TRUE) #acres/plot
  )

agc_pop <- inner_join(tree_totals, area_totals) |>
  group_by(YEAR) |>
  summarize(
    CARB_AG_TOTAL = sum(carbPlot, na.rm = TRUE), # tons/plot
    CARB_AG_VAR = var(carbPlot, na.rm = TRUE),
    CARB_AG_N = sum(carbPlot > 0, na.rm = TRUE),
    AREA_TOTAL = sum(forArea, na.rm = TRUE), # acres/plot
    AREA_VAR = var(forArea, na.rm = TRUE),
    AREA_N = sum(forArea > 0, na.rm = TRUE)
  ) |>
  # the units work out to still be tons(live carbon)/acre(forested land) even if the variable names are misleading
  mutate(method = "forestTIME", carbon_per_area = CARB_AG_TOTAL / AREA_TOTAL) |>
  select(
    method,
    YEAR,
    carbon_per_area,
    carbon_total = CARB_AG_TOTAL,
    carbon_total_var = CARB_AG_VAR,
    carbon_total_n = CARB_AG_N,
    area_total = AREA_TOTAL,
    area_total_var = AREA_VAR,
    area_n = AREA_N
  )
agc_pop
```

```{r}
#| label: plot-results

all <- bind_rows(
  agc_rfia_annual |>
    select(
      method,
      YEAR,
      carbon_per_area = CARB_ACRE,
      carbon_per_area_var = CARB_ACRE_VAR,
      carbon_total = CARB_TOTAL,
      carbon_total_var = CARB_TOTAL_VAR,
      carbon_n = nPlots_TREE,
      area_total = AREA_TOTAL,
      area_total_var = AREA_TOTAL_VAR,
      area_n = nPlots_AREA
    ),
  agc_rfia_ti |>
    select(
      method,
      YEAR,
      carbon_per_area = CARB_ACRE,
      carbon_per_area_var = CARB_ACRE_VAR,
      carbon_total = CARB_TOTAL,
      carbon_total_var = CARB_TOTAL_VAR,
      carbon_total_n = nPlots_TREE,
      area_total = AREA_TOTAL,
      area_total_var = AREA_TOTAL_VAR,
      area_n = nPlots_AREA
    ),
  agc_pop
)

ggplot(all, aes(x = YEAR, y = carbon_total, color = method)) +
  geom_line() +
  geom_ribbon(aes(
    ymin = carbon_total - 1.96 * sqrt(carbon_total_var),
    ymax = carbon_total + 1.96 * sqrt(carbon_total_var),
    fill = method
  ), color = NA, alpha = 0.4) +
  labs(y = "Total Carbon (tons)")

# NOTE: no CI for forestTIME method because it's not clear to me how to 
# calculate variance of a ratio with just `var()`
ggplot(all, aes(x = YEAR, y = carbon_per_area, color = method)) +
  geom_line() +
  geom_ribbon(aes(
    ymin = carbon_per_area - 1.96 * sqrt(carbon_per_area_var),
    ymax = carbon_per_area + 1.96 * sqrt(carbon_per_area_var),
    fill = method
  ), color = NA, alpha = 0.4) +
  labs(y = "Mean Carbon/Acre (tons/acre)")

```

We have some ballbark similar estimates to the ones `rFIA` produces.