---
title: "Population scaling"
vignette: >
  %\VignetteIndexEntry{Population scaling}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
format:
  html:
    toc: true
    df-print: paged
    link-external-newwindow: true
    link-external-icon: true
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
---

```{r}
#| label: setup

library(forestTIME.builder)
library(dplyr)
library(rFIA)
library(ggplot2)
```

How can we use the interpolated data produced by `forestTIME.builder` to get popluation-level (i.e. state-level) per-area estimates?

## Example data

I'll use RI as an example state because it is small.
We'll use the standard basic workflow to get estimated aboveground carbon for each tree in each year.

::: callout-important
`rFIA` produces estimates of carbon from 33 -- 40.7 tons/acre using design-based estimators.
"Correct" estimates should be in this ballpark.

```{r}
agc_rfia <- 
  biomass(fiaRI, method = "annual", treeType = "live", areaDomain = COND_STATUS_CD == 1 & INTENSITY == 1) |> 
  mutate(method = "rFIA::biomass()") |> 
  select(method, YEAR, carbon_ton_acre = CARB_ACRE)
mean(agc_rfia$carbon_ton_acre)
```
:::

```{r}
#| label: prep-data
state <- "RI"

# Data Download
fia_download(states = state, keep_zip = FALSE)

# Data prep
db <- fia_load(states = state) #list of data frames

data <- fia_tidy(db) #single tibble

# Expand to include all years between surveys and interpolate/extrapolate
# Adjust for mortality and estimate carbon.
data_midpt <-
  data |>
  expand_data() |>
  interpolate_data() |>
  adjust_mortality(use_mortyr = FALSE) |>
  prep_carbon() |>
  estimate_carbon() 
```

I'll add domain indicator columns as are done in the `rFIA` demystified vignette so we calculate carbon in live trees per area of forested land using base intensity plots only.
Reason:

> We build separate domain indicators for estimating tree totals and area totals, because we can specify different domains of interest for both.
> For example, if we used our tree domain (live trees on forest land) to estimate area, then we would not actually be estimating the full forested area in RI.
> Instead we would estimate the forested area ONLY where live trees are currently present.

So we can't just `filter(STATUSCD == 1 & COND_STATUSCD == 1)` to estimate carbon tons/acre.

```{r}
data_midpt <-
  data_midpt |>
  mutate(
    aDI = if_else(COND_STATUS_CD == 1 & INTENSITY == 1, 1, 0), #forested land
    tDI = if_else(STATUSCD == 1, 1, 0) * aDI #live trees on forested land
  )
```

## Expansion factors

The FIA data provides users with expansion factors, `EXPNS`, to aid in scaling estimates up to state levels.  There are two issues in using these provided `EXPNS` with our annualized data: 1) it is not straightforward to join the tables in to get the `EXPNS` column, and 2) there are now many more plots in each year, so the `EXPNS` column is no longer accurate (it is the land acres of the entire state represented by each plot).

Let's calculate our own expansion factor using the land area of RI.

According to this [USDA tool](https://experience.arcgis.com/experience/ddb54b68e915431182d406f9778694cb/page/Land-Resources-Dashboard), the total land area of RI is 781,730.1 acres.

```{r}
data_midpt <- data_midpt |>
  group_by(YEAR) |>
  mutate(
    EXPNS = 781730.1 / length(unique(plot_ID))
  )

data_midpt |>
  select(YEAR, EXPNS) |>
  group_by(YEAR) |>
  summarize(EXPNS = unique(EXPNS)) |>
  ggplot(aes(x = YEAR, y = EXPNS)) +
  geom_line()
```

You'll notice that our calculated `EXPNS` follow a "U" shape rather than being constant.  That is because in our interpolated data, there are fewer plots in the beginning and end of the timeseries because we do not extrapolate beyond a panel's first and last inventory.


Now that we have expansion factors, we can follow the methods in the [FIA demystified vignette](https://doserlab.com/files/rfia/articles/fiademystified#without-sampling-errors).

```{r}
tree_totals <- data_midpt |>
  group_by(plot_ID, YEAR) |>
  summarize(
    # purposefully omits ajustment factor `aAdj` because it is assumed to be 1
    carbPlot = sum(CARBON_AG * TPA_UNADJ * EXPNS * tDI / 2000, na.rm = TRUE), #tons/plot
  )

area_totals <- data_midpt |>
  group_by(plot_ID, YEAR) |>
  # Keep only one row for each condition in each plot and year
  distinct(CONDID, COND_STATUS_CD, CONDPROP_UNADJ, EXPNS, aDI) |>
  summarize(
    # purposefully omits ajustment factor `aAdj` because it is assumed to be 1
    forArea = sum(CONDPROP_UNADJ * EXPNS * aDI, na.rm = TRUE) #acres/plot
  )

agc_pop <- inner_join(tree_totals, area_totals) |> 
  group_by(YEAR) |> 
  summarize(
    CARB_AG_TOTAL = sum(carbPlot, na.rm = TRUE), #
    AREA_TOTAL = sum(forArea, na.rm = TRUE) #
  ) |>
  # the units work out to still be tons(live carbon)/acre(forested land) even if the variable names are misleading
  mutate(method = "annualized", carbon_ton_acre = CARB_AG_TOTAL / AREA_TOTAL) |>
  select(method, YEAR, carbon_ton_acre)
agc_pop
```

```{r}
bind_rows(agc_rfia, agc_pop) |> 
  ggplot(aes(x = YEAR, y = carbon_ton_acre, color = method)) +
  geom_line()

```

We have some ballbark similar estimates that are obviously very different in terms of temporal trend.