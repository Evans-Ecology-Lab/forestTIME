---
title: "Un-interpolatable trees"
date: today
format: 
  html:
    toc: true
code-fold: true
execute:
  warning: false
  message: false
knitr:
  opts_chunk: 
    out-width: 90%
    fig-width: 10
---

We currently drop trees from the dataset before interpolation for three main reasons:

1.  The tree changes `SPCD` at some point in it's life
2.  It was included by error---`RECONCILECD` is 7 or 8 at some point in it's life
3.  It only has one measurment for `HT` or `DIA` (even if it appears in multiple surveys)

1 and 2 are choices we've made (and could make differently), but 3 is due to a limitation—you can't "connect the dots" with interpolation if there's only one dot!

There are several (legit) reasons a tree might only have one measurement, each with different signals in the data.
We might approach these trees in different ways.

## Reasons a tree would only have one measurement


1.  It was alive or standing dead and then fell down before being measured again
    -   Signal:
        -   In one inventory, numbers for `HT` and `DIA`
        -   In the next inventory, `NA` for `HT` and `DIA`, `STATUSCD  = 2`, `STANDING_DEAD_CD = 0`
    - Possible solution: Cary the last (only) measurements forward until interpolated death year
2.  The plot the tree is in has only been visited once
    - Signal:
        -   The `plot_ID` and `tree_ID` should only show up in one year in the dataset
        -   `STATUSCD = 1` or `STANDING_DEAD_CD = 1` (alive or standing dead)
    -   Possible solutions: 
        - Only analyze data after the first cycle (after all plots in a state have been visited at least twice).  
        - Some trees may have a second measurement pre-2000—we could use the pre-2000 data for interpolation and filter it out after.
3.  Ingrowth
    - Signal:
        -   The `tree_ID` only appears once, but `plot_ID` shows up more than once
        -   `DIA` only slightly larger than 5
4. It was always fallen (I'm not sure if this is something that actually shows up in the data)
    - Signal:
        - Only `NA`s for `HT` and `DIA`
        - `STANDING_DEAD_CD = 0`
    - Solution: we would drop these anyway!

I'll try to tease all of these reasons out and plot them.

## The data

I'll read in the `TREE` table for a few states, add our `tree_ID` and `plot_ID` composite ID columns, and select columns of interest. 

```{r}
#| label: setup
#| include: false

library(forestTIME.builder)
library(tidyverse)
library(rFIA)

#states <- c("OR", "CA", "AZ", "DE", "RI", "ID", "AK", "MA", "CT")
states <-c("DE", "RI")

get_fia_tables(states = states, download_dir = here::here("fia"), keep_zip = TRUE)
```

```{r}
#| label: get-data
db <- readFIA(dir = here::here("fia"), states = states, tables = c("TREE", "COND"))
TREE <- db$TREE |>
  as_tibble() |>
  filter(INVYR >= 2000) |>
  add_composite_ids() |>
  left_join(state_codes, by = join_by(STATECD)) |>
  select(
    state_abb,
    plot_ID,
    tree_ID,
    CONDID,
    INVYR,
    HT,
    DIA,
    SPCD,
    STATUSCD,
    STANDING_DEAD_CD,
    RECONCILECD,
    CARBON_AG
  ) 

COND <-
    db$COND |>
    dplyr::filter(INVYR >= 2000L) |>
    add_composite_ids() |>
    dplyr::select(
      plot_ID,
      CONDID,
      INVYR,
      COND_STATUS_CD
    )

tree <- left_join(TREE, COND) |>
  arrange(state_abb, tree_ID, INVYR)
```

I'll do my best to programatically assign trees to each of these categories

::: callout-note
These categories *may* be non-mutually-exclusive
:::

First, a quick question: are there trees with measurments for `HT` but not `DIA` or vice versa?

```{r}
bind_rows(
  tree |>
    filter(!is.na(HT) & is.na(DIA)),
  tree |>
    filter(!is.na(DIA) & is.na(HT))
)
```

Quite a few!  I'm working under the assumption that we need *both* `HT` and `DIA` to estimate carbon, so we would need to drop a tree that meets the "only one measurement" condition for *either* of these variables.


## Status Quo

Currently, this is how our "rules" exclude trees from the sample before interpolation & extrapolation

```{r}
#| label: functions

reasons_fct <-
  c(
    "One or fewer measurements" = "na",
    "Never observed standing" = "always_fallen",
    "Fell after first inventory" = "fell",
    "Plot hasn't been revisited" = "only_visit",
    "Recorded species changes" = "spcd",
    "Included by error" = "error",
    "Ingrowth" = "ingrowth",
    "Condition change" = "nonsampled"
  )

wrangle_dropped_longer <- function(.data) {
  dropped_summary <- .data |>
    group_by(state_abb, INVYR) |>
    summarize(
      trees_total = length(unique(tree_ID)),
      across(
        starts_with("drop_"),
        \(x) sum(x, na.rm = TRUE),
        .names = "n_{.col}"
      ),
      carbon_total = sum(CARBON_AG, na.rm = TRUE),
      across(
        starts_with("drop_"),
        \(x) sum(CARBON_AG * x, na.rm = TRUE),
        .names = "carbon_{.col}"
      )
    )

  dropped_n_long <- dropped_summary |>
    select(-starts_with("carbon_drop_")) |>
    pivot_longer(
      starts_with("n_drop_"),
      names_prefix = "n_drop_",
      names_to = "reason",
      values_to = "n_dropped"
    )

  dropped_carbon_long <- dropped_summary |>
    select(-starts_with("n_drop_")) |>
    pivot_longer(
      starts_with("carbon_drop_"),
      names_prefix = "carbon_drop_",
      names_to = "reason",
      values_to = "carbon_dropped"
    )

  df_full <- full_join(
    dropped_n_long,
    dropped_carbon_long
  )
  reasons_fct <- reasons_fct[reasons_fct %in% unique(df_full$reason)]
  df_full |>
    mutate(reason_long = fct_recode(reason, !!!reasons_fct))
}


colors <- c(
  "One or fewer measurements" = "#666633",
  "Never observed standing" = "#72190E",
  "Fell after first inventory" = "#332288",
  "Plot hasn't been revisited" = "#225555",
  "Recorded species changes" = "#997700",
  "Included by error" = "#437DBF",
  "Ingrowth" = "#994F88",
  "Condition change" = "purple"
)

plot_dropped <- function(.data, y_var = c("n", "carbon")) {
  y_var <- match.arg(y_var)

  if (y_var == "n") {
    p <-
      ggplot(
        .data,
        aes(x = INVYR, y = n_dropped / trees_total, fill = reason_long)
      ) +
      labs(y = "Proportion of trees dropped")
  }

  if (y_var == "carbon") {
    p <-
      ggplot(
        .data,
        aes(x = INVYR, y = carbon_dropped / carbon_total, fill = reason_long)
      ) +
      labs(y = "Proportion of carbon in dropped trees")
  }
  p +
    facet_wrap(vars(state_abb)) +
    geom_col() +
    scale_fill_manual(values = colors) +
    scale_x_continuous(breaks = seq(2000, 2024, by = 2), minor_breaks = NULL) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.title = element_blank()
    )
}
```


```{r}
#| column: page
trees_dropped_current <- tree |>
  group_by(tree_ID) |>
  mutate(
    #just negating the `filter()` statements in `prep_data()`
    drop_na = !(sum(!is.na(DIA)) > 1 & sum(!is.na(HT)) > 1),
    # drop_na = !(sum(!is.na(DIA) & !is.na(HT)) >1), #should actually be this probably, but makes no obvious difference
    drop_spcd = !(length(unique(SPCD)) == 1),
    drop_error = any(RECONCILECD %in% c(7, 8))
  )

dropped_current <- wrangle_dropped_longer(trees_dropped_current)

dropped_current |>
  plot_dropped(y_var = "n")
dropped_current |>
  plot_dropped(y_var = "carbon")
```

**In some years, for some states, 100% of the trees would be excluded by our methods!**


## Detailed breakdown

Let's see if we can break this down into the different reasons for having one or fewer measurements in the data.

```{r}
#| label: filter-dropped

# how many times does each plot_ID show up in the data?
plot_inv_count <-
  tree |>
  select(plot_ID, INVYR) |>
  distinct() |> 
  count(plot_ID) |> 
  rename(plot_inv_count = n)

# add logical columns for each reason for possibly being dropped
# NOTE: `TRUE` means dropped and *either* `FALSE` or `NA` means not dropped
trees_dropped_detailed <- tree |>
  left_join(plot_inv_count, by = "plot_ID") |> 
  group_by(tree_ID) |>
  mutate(
    drop_spcd = length(unique(SPCD)) > 1,

    #tree was included by error
    drop_error = any(RECONCILECD %in% c(7, 8)),

    #exactly 1 measurement for both DIA and HT, more than one observation, and recorded as fallen at some point
    drop_fell = sum(!is.na(DIA) & !is.na(HT)) == 1 &
      n() > 1 &
      any(STANDING_DEAD_CD == 0),
    
    #fallen trees sometimes get diameter measurements and sometimes trees with no measurements have NA for STANDING_DEAD_CD
    drop_always_fallen = sum(!is.na(DIA) & !is.na(HT)) <= 1 &
       (all(STANDING_DEAD_CD == 0) | all(STATUSCD == 0)),

    # same as drop_fell, but plot and tree only exists once in dataset
    drop_only_visit = sum(!is.na(DIA) & !is.na(HT)) == 1 & 
      plot_inv_count == 1 &
      n() == 1,

    #small (non-NA) measurement for DIA, only one observation, plot has been inventoried previously
    drop_ingrowth = all(!is.na(DIA) & !is.na(HT)) &
      DIA < 10 | RECONCILECD == 1 & #either small or explicitly marked as ingrowth
      n() == 1 &
      plot_inv_count > 1,

    #tree was in a condition sampled in one inventory, but now in nonsampled condition
    drop_nonsampled = sum(!is.na(DIA) & !is.na(HT)) == 1 &
      n() > 1 &
      any(RECONCILECD == 9)
  )
```

Then we can summarize by state and inventory year to get a sense of how many trees are dropped, what proportion of total trees are represented by each category, and how much total carbon is represented by each category.

::: callout-note

The totals for a given year (total trees, total carbon) are only for the plots visited in that year

:::

```{r}
dropped_detailed <- wrangle_dropped_longer(trees_dropped_detailed)
```


```{r}
#| column: page
plot_dropped(dropped_detailed, y_var = "n")
```

```{r}
#| column: page
plot_dropped(dropped_detailed, y_var = "carbon")
```

::: callout-note

I obviously haven't captured all of the trees we are filtering out.  Not sure why!

:::

What trees am I missing in the more detailed dataset?

```{r}
#all rows in current dropped trees that don't show up in the detailed dropped trees
trees_dropped_not_accounted_for <- 
  anti_join(
  trees_dropped_current |>
    select(plot_ID, tree_ID, INVYR, starts_with("drop_")) |>
    filter(if_any(starts_with("drop_"), \(x) x == TRUE)),
  trees_dropped_detailed |>
    select(plot_ID, tree_ID, INVYR, starts_with("drop_")) |>
    filter(if_any(starts_with("drop_"), \(x) x == TRUE)),
  by = join_by(plot_ID, tree_ID, INVYR)
) 

tree |> 
  filter(tree_ID %in% unique(trees_dropped_not_accounted_for$tree_ID)) |>
  arrange(tree_ID, INVYR) |>  View()
```

Now, some of these trees would likely be removed from any analysis:

- Trees that were included by error (RECONCILECD 7 or 8)
- Trees that were never measured because they were never observed standing

I'll remove those from the total trees, re-calculate, and re-plot

```{r}
dropped_detailed2 <- tree_dropped |>
  ungroup() |> 
  dplyr::filter(drop_always_fallen == FALSE | is.na(drop_always_fallen)) |>
  dplyr::filter(drop_reconcilecd == FALSE | is.na(drop_reconcilecd)) |> 
  select(-drop_always_fallen, -drop_reconcilecd) |> 
  wrangle_dropped_longer()
  
```

```{r}
#| column: page
plot_dropped(dropped_detailed2, y_var = "n")
```

```{r}
#| column: page
plot_dropped(dropped_detailed2, y_var = "carbon")
```
