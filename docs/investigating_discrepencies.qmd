---
title: Investigating dropped trees
author: Eric R. Scott
format: html
code-fold: true
---

```{r}
#| label: setup

library(forestTIME.builder)
library(tidyverse)
library(duckdb)
library(DBI)
```

Because there are trees we *can't* interpolate (trees with only 1 observation) and trees we *won't* interpolate (e.g. trees that switch `SCPD`), there will be descrepencies between our methods and the "traditional estimators" regardless of whether we implement those methods correctly and appropriately for the interpolated data.  But, by how much will our estimates differ? When exploring methdods of estimating carbon in tons/acre for a state, it appears that the trees we drop for our interpolation can account for up to a third of the total carbon in a given year!  Here is some more thorough investigation of this

## Comparing raw data to our methods

I'll get the raw FIA data for Delaware and compare summaries of the `CARBON_AG` values from it with our calculated `CARBON_AG` values.

```{r}
# get original raw data
db <- read_fia(
  "DE",
  dir = system.file("exdata", package = "forestTIME.builder")
)

#get CARBON_AG and DRYBIO_AG values from raw data
orig <- db$TREE |>
  add_composite_ids() |>
  filter(INVYR >= 2000) |>
  select(tree_ID, INVYR, HT, DIA, ACTUALHT, STATUSCD, STANDING_DEAD_CD, RECONCILECD, TPA_UNADJ, CARBON_AG, DRYBIO_AG)
```

We can put the original data through our workflow *without interpolating* to get an idea of how it compares to the "built-in" carbon estimates.

```{r}
#Prep data and do carbon estimation (skip interpolation)
data_prepped <- prep_data(db) |>
  rename(YEAR = INVYR) |>
  prep_carbon() |>
  #add back TPA_UNADJ from raw data because we are skipping the interpolation steps that would add it
  left_join(orig |> select(tree_ID, YEAR = INVYR, TPA_UNADJ) |> distinct())

data <- data_prepped |>
  estimate_carbon() |>
  select(
    tree_ID,
    INVYR = YEAR,
    CARBON_AG_est = CARBON_AG,
    DRYBIO_AG_est = DRYBIO_AG
  )
```

Our methods can't estimate carbon if `HT` is missing.  What about in the raw data?

```{r}
orig |> 
  filter(is.na(HT) & !is.na(CARBON_AG))
```

Apparently whatever methods are used by FIA can calculate values for `CARBON_AG` without `HT` unlike the code we have from David Walker (I'll double-check this).

If we join the original data to our estimates, we can see where there are mismatches in terms of missing data.

```{r}
# Combine the two sets of carbon and biomass columns
test <- full_join(
  orig |> select(-TPA_UNADJ),
  data
)
```

Which observations are `NA` from `estimate_carbon()` but present in the original data?

```{r}
problems <- test |>
  #which rows have NAs from our methods but not in the raw data?
  filter(is.na(CARBON_AG_est) & !is.na(CARBON_AG)) |>
  select(tree_ID, INVYR)
```

Are these problem rows even *in* the prepped data?

```{r}
semi_join(data_prepped, problems, by = join_by(tree_ID, YEAR == INVYR))
```

No—all the missing values for carbon are because those trees weren't even included in the prepped data that went into carbon estimation.

Reasons we drop trees:

- `SPCD` changed
- Fewer than 2 recorded observations for `HT` or `DIA` (can't interpolate/extrapolate)
- `RECONCILECD` is 7 or 8

Now, we would probably remove trees with only `NA`s or with `RECONCILECD` 7 or 8 from the original raw data anyway, so let's see how many mismatches there are if we get rid of those.

```{r}
test <- test |> 
  group_by(tree_ID) |> 
  filter(!any(RECONCILECD %in% c(7,8))) |> 
  #sum of not NA values is not 0 means "there's at least 1 observation"
  filter(sum(!is.na(DIA)) != 0)
```

How much carbon is in the trees we drop in inventory years?

```{r}
carbon_dropped_summary <- test |>
  group_by(INVYR) |>
  # get yearly state totals for original and estimated (after dropping trees in
  # prep) to make a rough comparison
  summarize(
    n = n(),
    # this is valid in this case because we already determined all of the NAs were
    # from 'dropped' trees
    n_dropped = sum(is.na(CARBON_AG_est)),
    across(
      c(CARBON_AG, DRYBIO_AG, CARBON_AG_est, DRYBIO_AG_est),
      \(x) sum(x, na.rm = TRUE)
    )
  ) |>
  mutate(
    CARBON_dropped = CARBON_AG - CARBON_AG_est,
    DRYBIO_dropped = DRYBIO_AG - DRYBIO_AG_est
  ) |>
  mutate(
    prop_CARBON_dropped = CARBON_dropped / CARBON_AG,
    prop_DRYBIO_dropped = DRYBIO_dropped / DRYBIO_AG,
    prop_trees_dropped = n_dropped / n
  )
carbon_dropped_summary |> 
  select(INVYR, starts_with("prop_"))
```

In some years ***more than half*** of the trees surveyed are dropped and ***more than a third*** of the total carbon surveyed in the state is contained in trees that are dropped by our methods.

```{r}
carbon_dropped_summary |> 
  ggplot(aes(x = INVYR, y = prop_CARBON_dropped)) +
  geom_col() +
  labs(title = "DE", y = "Proportion of total carbon in 'dropped' trees")
```


## How does this vary by state?

So that was just Delaware.  Let's try to get an idea of what proportion of trees get dropped in some other states.  I'd like to eventually do this for all states, but for now it is a haphazard subset of states.

```{r}
get_fia_tables(
  states = c("DE", "AZ", "AK", "IL", "ID", "OR"),
  download_dir = here::here("fia"),
  keep_zip = TRUE
)
```

I'm going to use `duckdb` just to open all of the CSVs for TREE tables as one table. There are other ways to do this.

```{r}
#download any SQLite database from FIADB datamart and open
con <-
  dbConnect(RSQLite::SQLite(), dbname = here::here("data-raw/SQLite_FIADB_RI.db"))

#new connection for our tables to go to
con_duckdb <- dbConnect(duckdb::duckdb())

#get the column types from the SQLite database to provide to read function so CSVs get read in correctly
tree_types <- dbDataType(con_duckdb, collect(head(tbl(con, "TREE"))))

#read in all the **_TREE.csv tables
tree_csvs <- fs::dir_ls(here::here("fia"), regexp = "TREE")
names(tree_csvs) <- stringr::str_extract(tree_csvs, pattern = "\\w{2}(?=_)")

#let's just pick like 4 states for this data vis since I'm going to have to `collect()` the data before summarizing I think

tree_csvs <- tree_csvs[c("DE", "AZ", "AK", "IL", "ID", "OR")]

tree_db <- duckdb::duckdb_read_csv(
  conn = con_duckdb,
  name = "tree",
  files = tree_csvs,
  col.types = tree_types
)

tree_dropped_summary <-
  tbl(con_duckdb, "tree") |>
  dplyr::filter(INVYR >= 2000L) |>
  add_composite_ids() |>
  dplyr::select(
    tree_ID,
    STATECD,
    INVYR,
    # PLT_CN,
    # CONDID,
    # MORTYR,
    STATUSCD,
    RECONCILECD,
    # DECAYCD,
    STANDING_DEAD_CD,
    DIA,
    # CR,
    HT,
    # ACTUALHT,
    # CULL,
    SPCD
  ) |>
  collect() |> #can't get skip_spcd to work with database
  group_by(tree_ID) |>
  # filter out things we would filter out anyways:
  # - only NAs for DIA
  # - RECONCILECD is 7 or 8
  filter(!any(RECONCILECD %in% c(7, 8))) |> 
  filter(sum(!is.na(DIA)) != 0) |> 
  #figure out if trees would get dropped
  mutate(
    drop_dia_na = sum(!is.na(DIA)) <= 1, #one or fewer NAs
    drop_ht_na = sum(!is.na(HT)) <= 1,
    drop_spcd = length(unique(SPCD)) > 1 #more than 1 SPCD
  ) |>
  group_by(STATECD, INVYR) |>
  summarise(
    #technically these don't have to add up to 1 because they could be dropped for both reasons
    n_dropped_na = sum(drop_dia_na | drop_ht_na),
    n_dropped_spcd = sum(drop_spcd),
    n = n()
  ) |>
  mutate(
    prop_dropped_na = n_dropped_na / n,
    prop_dropped_spcd = n_dropped_spcd / n
  )

tree_dropped_summary |>
  pivot_longer(
    c(starts_with("prop_")),
    names_to = "Reason",
    values_to = "Proportion"
  ) |>
  left_join(state_codes) |>
  # filter(state_abb == "AK") |>
  mutate(
    Reason = case_when(
      Reason == "prop_dropped_na" ~ "≤ 1 non-NA `HT` or `DIA`",
      Reason == "prop_dropped_spcd" ~ "tree changes SPCD"
    )
  ) |>
  ggplot(aes(x = INVYR, y = Proportion, fill = Reason)) +
  geom_col() +
  facet_wrap(vars(state_abb)) +
  labs(y = "Proportion Trees Removed by `prep_data()`") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


Is it really the case that *100%* of the trees in AK and ID are being excluded by our methos??

```{r}
db_AK <- read_fia("AK", dir = here::here("fia"))
db_AK$TREE |> filter(INVYR == 2014) |> nrow()
db_AK |> prep_data() |> filter(INVYR == 2014) |> nrow()

db_ID <- read_fia("ID", dir = here::here("fia"))
db_ID$TREE |> filter(INVYR %in% 2012:2013) |> nrow()
db_ID |> prep_data() |> filter(INVYR %in% 2012:2013) |> nrow()
```

Wow! That is indeed the case! Uh... why???

```{r}
AK_2014 <- db_AK$TREE |>
  filter(INVYR == 2015) |> 
  add_composite_ids() |>
  group_by(tree_ID)

nrow_AK_total <- AK_2014 |> nrow()

nrow_AK_spcd <- AK_2014 |> 
  filter(length(unique(SPCD)) > 1) |> nrow()

nrow_AK_reconcilecd <- AK_2014 |> 
  filter(any(RECONCILECD %in% c(7, 8))) |> nrow()

nrow_AK_na_dia <- AK_2014 |> 
  filter(sum(!is.na(DIA)) <= 1) |> nrow()

nrow_AK_na_ht <- AK_2014 |> 
  filter(sum(!is.na(HT)) <= 1) |> nrow()
```

In Alaska in the 2014 inventory:

- there were `r nrow_AK_total` observations
- `r nrow_AK_spcd` observations were of trees that change `SPCD`
- `r nrow_AK_reconcilecd` observations were of trees that have a `RECONCILECD` of 7 or 8 at some point
- `r nrow_AK_na_dia` observations were of trees with only one measurement of `DIA`
- `r nrow_AK_na_ht` observatiosn were of trees with only one measurement of `HT` 

What does it mean that ***all*** of the trees measured in the state of Alaska in 2014 were only measured *once*?  Is it because those *plots* are only measured once?

```{r}
plot_sample <- db_AK$TREE |> 
  add_composite_ids() |> 
  filter(INVYR == 2014) |> 
  pull(plot_ID)

db_AK$TREE |>
  add_composite_ids() |> 
  filter(plot_ID %in% plot_sample) |> 
  pull(INVYR) |> unique()
```

Is it really the case that all `r length(unique(plot_sample))` plots inventoried in Alaska in 2014 have only been surveyed *once*?  Why isn't that the case for any other inventory year?